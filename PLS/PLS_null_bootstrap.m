function PLS_null_bootstrap(GENEdata_root, MRIdata_root, ncomp, bootnum, working_dir)
% PLS regression of null models
%% ------------------------- SCRIPT INFORMATION ---------------------------
%
% PLS Regression and bootstrapping for two null maps
%
% This script will perform two PLS regressions analysis for relative gene
% expression in 180 parcels against two null models of mean QSM signal.
% One null model is generated by randomly shuffling the values in all ROIs,
% one is generated by sphere-projection-rotation 
%
% This script is an adapted version of a script available from the
% following repository:
% https://github.com/KirstieJane/NSPN_WhitakerVertes_PNAS2016/
% Reference: Whitaker et al., 2016, PNAS
% Credit and thanks to the original author Petra Vertes
%
% Script last edited by:
% George Thomas July 2020
% - to run a PLS regression for a random permutation and a spatial
%   of the MRI data
% - to run with any number of components 
%
%----------------------------- INPUTS -------------------------------------
%
% GENEdata_root:
%   Name of genetic data .mat file, including Ngenes*NROI parcel expression
%   and probe information
%
% MRIdata_root:
%   Name of MRI data Nsubjects*NROI .mat file, containg participant QSM  
%   means Z-score transformed to control means for each ROI
%
% working_dir:
%   directory where MRIdata_root is and where output files will go
%
% ncomp:
%   number of dimensions (components) for the PLS 
%
% bootnum:
%   number of iterations for the boostrap runs
%
%------------------------------- OUTPUTS ----------------------------------
%
% The null phenotypes generated 
%   random_null_<MRIdata_root>.mat
%   spatial_null_<MRIdata_root>.mat
%
% PLS<comp>_<null_type>_ROIscores_<MRIdata_root>.csv
%   ncomp x files containing PLS weight in NROI regions for that component
%
% PLS<comp>_<null_type>_geneWeights_<MRIdata_root>.csv
%   ncomp x files conatining ranked, boostrapped gene weights for each
%   component in the format 
%   geneID      geneIndex       geneZscore
%
%----------------------------- DEPENDENCIES -------------------------------
% 
% rotate_parcellation_fixed_LH.m
% sphere_HCP.txt
%
% Documentaion about the above code and coordinates is available from:
% https://github.com/frantisekvasa/rotate_parcellation/
% Credit and thanks to the author František Váša

%% ------------------------ SCIPT BEGINS HERE -----------------------------
tic
%% Import and tidy variables
disp('>>> importing + tidying variables')
disp(' ')

% get output directroy full path and add
working_dir = [pwd, working_dir];
addpath(working_dir);

% load NROI*Ngenes gene expression matrix (LH only) as well as probeInfo
load([GENEdata_root '.mat']);
GENEdata = parcelExpression;
GENEdata(:,1) = [];
% Replace NaN Gene/ROI entries with mean expression in that ROI
for g = 1:size(GENEdata,2)
    GENEdata(isnan(GENEdata(:,g)),g) =...
        mean(GENEdata(~isnan(GENEdata(:,g)),g));
end
GENEids = probeInformation.GeneSymbol;
GENEindex=(1:length(GENEids))';

% import matrix of Nsubjects*NROI MRI data
QSMdata  = importdata([MRIdata_root '.mat']);

disp('>>> grouping + averaging MRI data')
disp(' ')
% calculate average QSM score in each region and convert to column vector
mean_MRIdata = (mean(QSMdata))';

%% define null models and save 

% make a random permutation
randomPerm = randperm(size(mean_MRIdata,1));
Yrandom=mean_MRIdata(randomPerm,:);
% save this map
save([working_dir '/random_null_' MRIdata_root '.mat'], 'Yrandom');

% import Glasser ROI coordinates
lh_coords = importdata('sphere_HCP.txt');
% take LH only
lh_coords = lh_coords(1:180,:);
% do one sphere-projection-rotation and get the indeces
spatialPerm = rotate_parcellation_fixed_LH(lh_coords,1);
% resample the MRI data to get a spatial permutation
Yspatial = mean_MRIdata(spatialPerm);
% save this map
save([working_dir '/spatial_null_' MRIdata_root '.mat'], 'Yspatial');


%% run initial PLS for both random and spatial nulls

X=GENEdata;

for ptype = 1:2;
    
    if ptype == 1
        disp('>>> RANDOM NULL MODEL <<<');
        Y = Yrandom;
        fname1_root = 'random_null_PLS%01d_ROIscores_';
        fname2_root = 'random_null_PLS%01d_geneWeights_';
    else 
        disp('>>> SPATIAL NULL MODEL <<<');
        Y = Yspatial;
        fname1_root = 'spatial_null_PLS%01d_ROIscores_';
        fname2_root = 'spatial_null_PLS%01d_geneWeights_';
    end
    
    disp(['>>> running initial PLS in ' num2str(ncomp) ' dimensions'])
    [~,~,XS,~,~,PCTVAR,~,stats]=plsregress(X,Y,ncomp);
    disp(' ')
    disp('cumulative % variance explained in Y:')
    disp(' ')
    disp(cumsum(100*PCTVAR(2,:)))
    
    % calculate correlation with input data
    disp('correlation of PLS components with MRI data:');
    [rho, pval] = corr(Y, XS)
    
    % make empty matrices to store weights and info from initial PLS run
    PLSinitW = zeros(length(GENEindex),ncomp);
    PLSinitIdx = zeros(length(GENEindex),ncomp);
    PLSinitID = cell(length(GENEindex),ncomp);
    PLSgeneIndex = zeros(length(GENEindex),ncomp);
    
    % store info for each component and align with desired direction
    for cc = 1:ncomp
        if rho(cc)<0
            stats.W(:,cc)=-1*stats.W(:,cc);
            XS(:,cc)=-1*XS(:,cc);
        end
        [PLSinitW(:,cc),PLSinitIdx(:,cc)] = sort(stats.W(:,cc),'descend');
        PLSinitID(:,cc)=GENEids(PLSinitIdx(:,cc));
        PLSgeneIndex(:,cc)=GENEindex(PLSinitIdx(:,cc));
    end
    
    %% save ROI weights to .csv
    
    disp('>>> saving ROI weights')
    for cc = 1:ncomp
        fname1 = [sprintf(fname1_root,cc) MRIdata_root '.csv'];
        csvwrite(fullfile(working_dir,fname1),XS(:,cc));
    end
    disp(' ')
    
    %% bootstrapping
    
    % define variable for storing the (ordered) weights from all bootstrap runs
    PLSbootW=zeros(length(GENEindex),bootnum,ncomp);
    
    % start bootstrap
    disp('>>> Bootstrapping - could take a while')
    for bb=1:bootnum
        myresample = randsample(size(X,1),size(X,1),1);
        % define X for resampled regions
        Xr=X(myresample,:);
        % define Y for resampled regions
        Yr=Y(myresample,:);
        % perform PLS for resampled data
        [~,~,~,~,~,~,~,stats]=plsregress(Xr,Yr,ncomp);
        
        % for each component
        for cc = 1:ncomp
            % extract PLS components weights
            temp=stats.W(:,cc);
            % order the newly obtained weights the same way as initial PLS
            newW=temp(PLSinitIdx(:,cc));
            % the sign of PLS components is arbitrary - make sure this aligns between runs
            if corr(PLSinitW(:,cc),newW)<0
                newW=-1*newW;
            end
            % store (ordered) weights from this bootstrap run
            PLSbootW(:,bb,cc)=newW;
        end
        
        % report progress
        if mod(bb,100) ==0
            disp(['iteration ' num2str(bb) ' of ' num2str(bootnum)])
        end
    end
    disp(' ')
    %% save results
    
    % make matrix for storing stdevs and Z scores from bootstrapping
    PLSstdW = zeros(length(GENEindex),ncomp);
    PLSzW = zeros(length(GENEindex),ncomp);
    PLSzIdx = zeros(length(GENEindex),ncomp);
    PLSzID = cell(length(GENEindex),ncomp);
    
    disp('>>> saving bootstrapped gene weights')
    disp(' ')
    % for all components
    for cc = 1:ncomp
        
        % get standard deviation of weights from bootstrap runs
        PLSstdW(:,cc)=std(PLSbootW(:,:,cc),0,2);
        
        % get bootstrap weights
        temp=PLSinitW(:,cc)./PLSstdW(:,cc);
        
        % order bootstrap weights (Z) and names of genes
        [PLSzW(:,cc), PLSzIdx(:,cc)]=sort(temp,'descend');
        PLSzID(:,cc)=PLSinitID(PLSzIdx(:,cc));
        PLSgeneIndex(:,cc)=PLSgeneIndex(PLSzIdx(:,cc));
        
        % save results to .csv
        fname2 = [sprintf(fname2_root,cc) MRIdata_root '.csv'];
        fid = fopen(fullfile(working_dir,fname2),'w');
        for ii=1:length(GENEids)
            fprintf(fid,'%s, %d, %f\n',...
                PLSzID{ii,cc}, PLSgeneIndex(ii,cc), PLSzW(ii,cc));
        end
        fclose(fid);
    end
    
end
disp(' ')
disp('Done!')
%% report speed
toc